# Structure and Interpretation of Computer Programs (SICP)

## Overview
This repo's purpose is to keep track of all the work I've done as I go through the Structure and Interpretation of Computer Programs text. When I started SICP, I didn't have much knowledge of `Scheme`, so I've been using `DrRacket` as the main IDE for building programs. Because of the many flavors of `Scheme`, one quirk of `DrRacket` is that you can declare the Scheme dialect at the top of your file with `#lang <scheme-dialect-of-choice>`. Therefore, if you look at the programs I've created across chapters, they will be written in a few different languages as I've learned more about what `DrRacket` offers. The languages I've used vary from `Racket` to `Scheme` to the SICP-compatible flavor of Scheme that I've settled on `SICP`. As a result, one thing to watch out for are the different syntaxes involving mutable data types in some parts of chapter 3 where I used `Scheme` since I hadn't known about `SICP` lang at the time. Newer versions of `Scheme`, including the one I used in the mutation section of chapter 3, urges in its implementation for programmers not to mutate pairs. Instead of the `set-car!` and `set-cdr!` procedures in the text that are applicable to `pair` types, more explicit mutation procedures `set-mcar!` and `set-mcdr!` are applicable to `mpair`. There are of course other quirks in my programs because I chose not to explicitly structure my work via the completed examples but rather the sections of text I read with notes and included procedures in the text for tinkering.

With that aside, a great resource for following along in the text is Brian Harvey's set of CS61A lectures which can be found https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E (playlists of his lectures can also be found on YouTube) while the SICP text is offered free online at https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html. I hope that should you stumble upon this repo, it aids in developing your understanding of the primary abstractions used in programming.

### Chapter 1
This chapter is primarily devoted to developing a basic understanding of recursion and a basic introduction to lambda functions, without truly acknowledging its intracies and more interesting applications. My chapter 1 work is more disorderly than my work in other chapters for two reasons. One, everything in this chapter is in `Racket`, which is slightly different than the code in the text. The text's procedure outputs are generally the same though with different syntax, it may be slightly more difficult to follow along at times. Two, the programs are not split by section, which can also contribute to making my work here difficult to follow along. To remedy these issues, I will reorganize `ch1` at some point to make it more comprehensible.

### Chapter 2
Chapter 2 discusses with the nature of abstraction and its implications for modularity in programming. Procedures and programs should be built on one another with implementation details separate from one another. This concept of creating layers of building blocks as tools for other programs to utilize in order to construct full programs is central to chapter 2's thesis. One thing to note is that part-way through my work, I realized I could switch languages from `Racket` to `Scheme` so the work in the latter half of `ch2` more closely resembles the text.

